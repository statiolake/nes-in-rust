/*
 * AUTOGENERATED by mrustc
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>
typedef uint32_t RUST_CHAR;
typedef uint8_t RUST_BOOL;
typedef struct { void* PTR; int META; } SLICE_PTR;
typedef struct { void* PTR; void* META; } TRAITOBJ_PTR;
typedef struct { void (*drop)(void*); int size; int align; } VTABLE_HDR;
typedef struct { char _d; } tUNIT;
typedef struct { char _d; } tBANG;
typedef struct { char _d; } tTYPEID;
static int ALIGN_TO(int s, int a) { return (s + a-1) / a * a; }

extern void _Unwind_Resume(void) __attribute__((noreturn));
#define ALIGNOF(t) __alignof__(t)
extern jmp_buf*    mrustc_panic_target;
extern void* mrustc_panic_value;
static int __builtin_ctz(uint32_t v) { int rv = 0; for (; rv < 32 && (v & (1 << rv)) == 0; rv++); return rv; }
static int __builtin_clz(uint32_t v) { int rv = 32; for (; rv >= 0 && (v & (1 << rv)) == 0; rv--); return rv; }
static int __builtin_popcount(uint32_t v) { int i, rv = 0; for (i = 0; i < 32; i++) if ((v & (1 << i)) != 0) rv++; return rv; }
static int __builtin_bswap16(uint16_t v) { return (v << 8) | (v >> 8); }
static int __builtin_bswap32(uint32_t v) { return ((v & 0x000000FF) << 24) | ((v & 0x0000FF00) << 8) | ((v & 0x00FF0000) >> 8) | ((v & 0xFF000000) >> 24); }
static bool __builtin_mul_overflow_u8(uint8_t a, uint8_t b, uint8_t* out) {
	*out = a*b;
	if(b == 0) return false;
	if(a > UINT8_MAX/b)  return true;
	return false;
}
static bool __builtin_mul_overflow_i8(int8_t a, int8_t b, int8_t* out) {
	*out = a*b;
	if(b == 0) return false;
	if(a > INT8_MAX/b)  return true;
	if(a < INT8_MIN/b)  return true;
	if( (a == -1) && (b == INT8_MIN))  return true;
	if( (b == -1) && (a == INT8_MIN))  return true;
	return false;
}
static bool __builtin_mul_overflow_u16(uint16_t a, uint16_t b, uint16_t* out) {
	*out = a*b;
	if(b == 0) return false;
	if(a > UINT16_MAX/b)  return true;
	return false;
}
static bool __builtin_mul_overflow_i16(int16_t a, int16_t b, int16_t* out) {
	*out = a*b;
	if(b == 0) return false;
	if(a > INT16_MAX/b)  return true;
	if(a < INT16_MIN/b)  return true;
	if( (a == -1) && (b == INT16_MIN))  return true;
	if( (b == -1) && (a == INT16_MIN))  return true;
	return false;
}
static bool __builtin_mul_overflow_u32(uint32_t a, uint32_t b, uint32_t* out) {
	*out = a*b;
	if(b == 0) return false;
	if(a > UINT32_MAX/b)  return true;
	return false;
}
static bool __builtin_mul_overflow_i32(int32_t a, int32_t b, int32_t* out) {
	*out = a*b;
	if(b == 0) return false;
	if(a > INT32_MAX/b)  return true;
	if(a < INT32_MIN/b)  return true;
	if( (a == -1) && (b == INT32_MIN))  return true;
	if( (b == -1) && (a == INT32_MIN))  return true;
	return false;
}
static bool __builtin_mul_overflow_usize(uintptr_t a, uintptr_t b, uintptr_t* out) {
	return __builtin_mul_overflow_u16(a, b, out);
}
static bool __builtin_mul_overflow_isize(intptr_t a, intptr_t b, intptr_t* out) {
	return __builtin_mul_overflow_i16(a, b, out);
}
static bool __builtin_sub_overflow_u32(uint32_t a, uint32_t b, uint32_t* o) {
	*o = a - b;
	return a < b;
}
static bool __builtin_sub_overflow_u16(uint16_t a, uint16_t b, uint16_t* o) {
	*o = a - b;
	return a < b;
}
static bool __builtin_sub_overflow_u8(uint8_t a, uint8_t b, uint8_t* o) {
	*o = a - b;
	return a < b;
}
static bool __builtin_sub_overflow_usize(uintptr_t a, uintptr_t b, uintptr_t* out) {
	return __builtin_sub_overflow_u16(a, b, out);
}
static bool __builtin_add_overflow_u32(uint32_t a, uint32_t b, uint32_t* o) {
	*o = a + b;
	return a > UINT32_MAX - b;
}
static bool __builtin_add_overflow_u16(uint16_t a, uint16_t b, uint16_t* o) {
	*o = a + b;
	return a > UINT16_MAX - b;
}
static bool __builtin_add_overflow_u8(uint8_t a, uint8_t b, uint8_t* o) {
	*o = a + b;
	return a > UINT8_MAX - b;
}
static bool __builtin_add_overflow_usize(uintptr_t a, uintptr_t b, uintptr_t* out) {
	return __builtin_add_overflow_u16(a, b, out);
}
static bool __builtin_sub_overflow_i32(int32_t a, int32_t b, int32_t* o) {
	*o = a - b;
	return ((b < 0) && (a > INT32_MAX + b)) || ((b > 0) && (a < INT32_MIN + b));
}
static bool __builtin_sub_overflow_i16(int16_t a, int16_t b, int16_t* o) {
	*o = a - b;
	return ((b < 0) && (a > INT16_MAX + b)) || ((b > 0) && (a < INT16_MIN + b));
}
static bool __builtin_sub_overflow_i8(int8_t a, int8_t b, int8_t* o) {
	*o = a - b;
	return ((b < 0) && (a > INT8_MAX + b)) || ((b > 0) && (a < INT8_MIN + b));
}
static bool __builtin_sub_overflow_isize(intptr_t a, intptr_t b, intptr_t* out) {
	return __builtin_sub_overflow_i16(a, b, out);
}
static bool __builtin_add_overflow_i32(int32_t a, int32_t b, int32_t* o) {
	*o = a + b;
	return ((b > 0) && (a > INT32_MAX - b)) || ((b < 0) && (a < INT32_MIN - b));
}
static bool __builtin_add_overflow_i16(int16_t a, int16_t b, int16_t* o) {
	*o = a + b;
	return ((b > 0) && (a > INT16_MAX - b)) || ((b < 0) && (a < INT16_MIN - b));
}
static bool __builtin_add_overflow_i8(int8_t a, int8_t b, int8_t* o) {
	*o = a + b;
	return ((b > 0) && (a > INT8_MAX - b)) || ((b < 0) && (a < INT8_MIN - b));
}
static bool __builtin_add_overflow_isize(intptr_t a, intptr_t b, intptr_t* out) {
	return __builtin_add_overflow_i16(a, b, out);
}
typedef int int64_t;
typedef int uint64_t;
typedef int int128_t;
typedef int uint128_t;


static int slice_cmp(SLICE_PTR l, SLICE_PTR r) {
	int rv = memcmp(l.PTR, r.PTR, l.META < r.META ? l.META : r.META);
	if(rv != 0) return rv;
	if(l.META < r.META) return -1;
	if(l.META > r.META) return 1;
	return 0;
}
static SLICE_PTR make_sliceptr(void* ptr, int s) { SLICE_PTR rv; rv.PTR = ptr; rv.META = s; return rv; }
static TRAITOBJ_PTR make_traitobjptr(void* ptr, void* vt) { TRAITOBJ_PTR rv; rv.PTR = ptr; rv.META = vt; return rv; }

static int mrustc_max(int a, int b) { return a < b ? b : a; }
static void noop_drop(tUNIT *p) { }

static int mrustc_string_search_linear(SLICE_PTR val, int count, SLICE_PTR* options) {
	int i;
	for(i = 0; i < count; i ++) {
		int cmp = slice_cmp(val, options[i]);
		if(cmp < 0) break;
		if(cmp == 0) return i;
	}
	return SIZE_MAX;
}
static const uint8_t __mrustc_revmap[16] = { 0, 8, 4,12, 2,10, 6,14,  1, 9, 5,13, 3, 7,15};
static uint8_t __mrustc_bitrev8(uint8_t v) { if(v==0||v==0xFF) return v; return __mrustc_revmap[v>>4]|(__mrustc_revmap[v&15]<<4); }
static uint16_t __mrustc_bitrev16(uint16_t v) { if(v==0) return 0; return ((uint16_t)__mrustc_bitrev8(v>>8))|((uint16_t)__mrustc_bitrev8(v)<<8); }
static uint32_t __mrustc_bitrev32(uint32_t v) { if(v==0) return 0; return ((uint32_t)__mrustc_bitrev16(v>>16))|((uint32_t)__mrustc_bitrev16(v)<<16); }
static uint8_t __mrustc_op_umax8(uint8_t a, uint8_t b) { return (a > b ? a : b); }
static uint8_t __mrustc_op_umin8(uint8_t a, uint8_t b) { return (a < b ? a : b); }
static uint8_t __mrustc_op_imax8(uint8_t a, uint8_t b) { return ((int8_t)a > (int8_t)b ? a : b); }
static uint8_t __mrustc_op_imin8(uint8_t a, uint8_t b) { return ((int8_t)a < (int8_t)b ? a : b); }
static uint8_t __mrustc_op_and_not8(uint8_t a, uint8_t b) { return ~(a & b); }
static uint16_t __mrustc_op_umax16(uint16_t a, uint16_t b) { return (a > b ? a : b); }
static uint16_t __mrustc_op_umin16(uint16_t a, uint16_t b) { return (a < b ? a : b); }
static uint16_t __mrustc_op_imax16(uint16_t a, uint16_t b) { return ((int16_t)a > (int16_t)b ? a : b); }
static uint16_t __mrustc_op_imin16(uint16_t a, uint16_t b) { return ((int16_t)a < (int16_t)b ? a : b); }
static uint16_t __mrustc_op_and_not16(uint16_t a, uint16_t b) { return ~(a & b); }
static uint32_t __mrustc_op_umax32(uint32_t a, uint32_t b) { return (a > b ? a : b); }
static uint32_t __mrustc_op_umin32(uint32_t a, uint32_t b) { return (a < b ? a : b); }
static uint32_t __mrustc_op_imax32(uint32_t a, uint32_t b) { return ((int32_t)a > (int32_t)b ? a : b); }
static uint32_t __mrustc_op_imin32(uint32_t a, uint32_t b) { return ((int32_t)a < (int32_t)b ? a : b); }
static uint32_t __mrustc_op_and_not32(uint32_t a, uint32_t b) { return ~(a & b); }
struct t_ZRTA6Ca ;
// PROTO extern "Rust" ::"bin#"::start
intptr_t  ZRG1cD3bin5start0g(
		intptr_t arg0, // isize
		uint8_t **arg1 // *const *const u8
		) // -> isize
;
// EXTERN extern "C" ::"bin#"::cprintf
extern void  cprintf(
		uint8_t *arg0, // *const u8
		...
		) // -> ()
;
void  ZRG1cD3bin7cprintf0g(
		uint8_t *arg0, // *const u8
		...
		) // -> ()
 { cprintf(arg0); }
;
// ::"bin#"::start
intptr_t  ZRG1cD3bin5start0g(
		intptr_t arg0, // isize
		uint8_t **arg1 // *const *const u8
		) // -> isize

{
	intptr_t rv;
	struct t_ZRTA6Ca *var0;	// &'static [u8; 6]
	struct t_ZRTA6Ca *var1;	// *const [u8; 6]
	uint8_t *var2;	// *const u8
	var0 = (void*)"hello\x00";	// _0 = Constant(b"hello\x00")
	var1 = (struct t_ZRTA6Ca *)var0;	// _1 = Cast(_0 as *const [u8; 6])
	var2 = (uint8_t *)var1;	// _2 = Cast(_1 as *const u8)
	ZRG1cD3bin7cprintf0g( var2 );
	// ^ Call( _3 = ::"bin#"::cprintf( _2, ), bb1, bb2)
bb1:
	goto bb1;
	// ^ Goto(1)
bb2: _Unwind_Resume(); // Diverge
}
int main(int argc, uint8_t* argv[]) {
	return ZRG1cD3bin5start0g(argc, argv);
}
jmp_buf* mrustc_panic_target;
void* mrustc_panic_value;
int8_t* __rust_alloc(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc(a0, a1);
}
void __rust_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2) {
	extern void __rdl_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2);
	__rdl_dealloc(a0, a1, a2);
}
int8_t* __rust_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3) {
	extern int8_t* __rdl_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3);
	return __rdl_realloc(a0, a1, a2, a3);
}
int8_t* __rust_alloc_zeroed(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc_zeroed(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc_zeroed(a0, a1);
}
struct s_ZRG2c4core5alloc6Layout0g_A { uintptr_t a, b; };
void oom_impl(struct s_ZRG2c4core5alloc6Layout0g_A l) { extern void ZRG1cE9core0_0_019alloc_error_handler0g(struct s_ZRG2c4core5alloc6Layout0g_A l); ZRG1cE9core0_0_019alloc_error_handler0g(l); }
uint32_t panic_impl(uintptr_t payload) {extern uint32_t ZRG1cE9core0_0_010panic_impl0g(uintptr_t payload);return ZRG1cE9core0_0_010panic_impl0g(payload);}

uint32_t ZRG1cE9core0_0_010panic_impl0g(uintptr_t payload) { while (1); }
void ZRG1cE9core0_0_019alloc_error_handler0g(void) { while (1); }
void _Unwind_Resume(void) { while (1); }
int8_t *__rdl_alloc(uintptr_t size, uintptr_t align) { while (1); }
int8_t *__rdl_alloc_zeroed(uintptr_t a0, uintptr_t a1) { while (1); }
void __rdl_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2) { while (1); }
int8_t* __rdl_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3) { while (1); }